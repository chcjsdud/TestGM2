// 019_Array.cpp : 이 파일에는 'main' 함수가 포함됩니다. 거기서 프로그램 실행이 시작되고 종료됩니다.
//

#include <iostream>



int main()
{
    // 변수 선언 이런 메모리 영역을 만들어야해 쓸꺼야 등등.
    
    // 배열의 선언 방법 
    // 자료형 이름[unsigned 정수]
    // 0이나 -1 등은 들어가기 힘들고
    // 컴파일러가 에러를 낼것이다.
    // C에서는 됐다.

    // 이런식으로 만듭니다.
    // int를 한번에 100개 만들고 메모리를 완벽하게 다닥다닥 붙여라.
    // [][][][][]
    // 배열을 == 포인터
    // 배열의 이름 == 포인터
    // int* != int[]
    // 둘의 자료형이 같다라고 표현하려면
    // 컴파일 모든 연산자와 모든 결과가 동일해야 같은 자료형으로 봅니다.

    // 왜 이런 오해를 할까?
    {
        //int Arr[5] = {0, 1, 2, 3, 4};

        // (int*)<= int 주소형

        int* ArrPtr[10];


        int Arr[5] = {};

        // 암시적형변환이 된다.
        int* PtrArr = Arr;

        // 배열의 이름을 사용하면 우리가 배웠던 포인터 연산을
        // 그대로 사용할수가 있다.
        *Arr;

        int* Ptr = Arr + 1;

        // Arr = Arr + 1;

        int ArrSize = sizeof(Arr);
        int PtrSize = sizeof(PtrArr);

        int a = 0;
    }

    // 문자열은 특별하게 컴파일러가 처리합니다.
    {
        // 문자열을 잘해야하는 이유는 인간이기 때문이다.
        // 이렇게 할필요가 없습니다.
        

        // ABCDE를 넣었는데 왜 안들어가지?
        // char Arr[5] = "ABCDE";

        // 맨뒤에 0을 넣자가 모든 프로그래머들이 약속한거야. 
        // 맨뒤에 0을 넣는이유는 0이 나오면 문자열의 끝이라고 생각하자.

        // 5개는 내가 만들고 무엇이 있는지 아는 영역.
        // 100
        char Arr[5] = { 'A', 'B', 'C', 'D', 'E'};

        // 보통 배열에서 특정한 위치의 값을 꺼내오는 것을 다음과 같이
        // 포인터 문법으로 처리한다.

        // Arr = 100 + sizeof(char) * 0;

        //         // 100번지의 값
        char Ch0 = Arr[0];
        //         // 101번지의 값
        char Ch1 = Arr[1];
        char Ch2 = Arr[2];
        char Ch3 = Arr[3];
        char Ch4 = Arr[4];

        //int ArrInt[5] = { 1, 2, 3, 4, 5 };
        //char* ConvertPtr = reinterpret_cast<char*>(ArrInt);

        char* Ptr = Arr;

        // 앞으로 사용할 모든 문자열 함수에서 마지막에
        // 0이 들어가지 않은 문자열을 사용했을때 나오는 결과는 랜덤.
        // 
        // 어거지로 하면 된다.
        printf_s(Arr);


        int a = 0;
    }
}
