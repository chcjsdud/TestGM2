// 005_operator.cpp : 이 파일에는 'main' 함수가 포함됩니다. 거기서 프로그램 실행이 시작되고 종료됩니다.
//

#include <iostream>

int main()
{
	// 실제적인 변수의 선언 그자체도
	// 만들면서 초기값이라는 것을 지정해주고 싶어진다.
	// =  <= 연산자
	// 변수의 값에 변화를 주는 연산을 명령하는 기호들
	// 10 <= 상수
	// 상수 초기화 => 리터럴 초기화라고 부릅니다.

	int PlayerHp = 0;
	// 알고 싶지 않다.
	// 초기화를 안하는 인간은 범죄자라고 부릅니다.
	// 초기화를 안하면 버그의 온상이 됩니다.

	// 초기화 안했을때의 디버그 상태에서는 안터지던게
	// 출시버전이라는 빌
	// 디버그할때는 못느끼다가 출시버전에서 터집니다.

	// Main영역내부에 4바이트의 PlayerHp의 영역을 만들고
	// PlayerHp의 영역에 코드영역에 존재하는 15의 위치를 존재하는 4바이트의 
	// 메모리를 PlayerHP에 복사해라.

	// = 연산자를 대입연산자라고 부르는데.
	// LValue = RValue 

	// RValue의 메모리영역을 LValue 메모리 영역에 복사해라.
	// 상수는 일반적으로 LValue가 될수 없습니다.

	// ; <= 종결자 보통 코딩에서 의미있는 1줄을 말하고
	// 여기서 의미있는 1줄이 끝났다.

	// left를 만들고 거기에 3을 넣어라 끝(;)
	int Left = 3;
	// Right를 만들고 거기에 5을 넣어라 끝(;)
	// Right를 만들고 거기에 5을 넣어라 끝(;)
	int Result = 0;

	int Right = (Left + 2);

	// C++ 에서 메모리영역의 규칙은
	// 만들고 나서 사용한다.
	// 최초선언할때는 대입연산자 밖에 쓸수없고
	// 메모리가 만들어지는 순간 사용하는 대입연산자는
	// 초기화 작업에 사용됬다고 표현한다.
	// 초기화 대입
	// int Left = 3;
	// 대입
	// Left = 3;

	// 함수 == 연산자(표현이 조금 다른 함수)

	// 연산자는 1항 2항 3항 연산자가 있습니다.
	// 연산자를 사용하기 위한 메모리영역의 개수

	// 1. 모든 연산자는 결과가 있습니다.
	// 2. 모든 연산자는 항으로 표현합니다.

	// 산술연산자(사칙연산)
	//        3      5
	Result = Left + Right; // 2항
	Result = Left - Right; // 2항
	Result = Left * Right; // * 아스테리크
	// 정수의 산술연산은 정수의 결과밖에 나오지 않는다.
	// 나머지는 다 버린다.
	Result = Left / Right; // 0
	// Result 받는쪽도 정수인데.
	// 실수가 절대 될수 없으므로 소수점 자체가 존재할수 없다.
	Result = Right / Left; // 1

	// 나머지 5 3 나눠서 나오는 나머지를 출력합니다.
	Result = Right % Left; // 2
	//       3      5
	Result = Left % Right; // 3

	// 심각한 오류

	// division by zero
	// 제로 디비전
	// 절대로 하면 안되는 것
	// Result = Right / 0; // 1

	// 비교 & 관계 연산자
	// 자료형 크기와     처리 형태
	// int    4(바이트)  정수
	// bool   1          논리(참과 거짓을 나타내는 것.)

	//     메모리 영역
	// int 00000000 00000000 00000000 00000000 
	// 참과 거짓을 의미하는 것은 딱 1가지밖에 없습니다.
	// 모든 비트가 0이면 거짓
	// 그중 단 1개라도 1이면 참
	// C++은 C에서 내려왔다.
	// 너무 혼동되는데?
	// 아예 참과 거짓을 전문으로 
	// C 99(컴파일러 버전) 까지는 없었다. 

	// true false를 표현하는 상수도 만들자.
	// 0이닌 수 참.
	// 정수로 만들면 1이 됩니다.
	bool bResult = true;
	// 0만 아니면 다 true가 된다.
	bResult = 300;
	// C++ 과거의 관습들도 포용하자라는 식으로 가서
	// 다른 메모리영역도 복사가 된다.
	bResult = 'a';
	bResult = true; // 1
	bResult = false; // 0

	// 비교 관계연산자의 결과값은 무조건 논리형
	// true 아니면 false

	// Left와 Right가 같다면 true 틀리다면 false
	bResult = Left == Right;
	Result = Left == Right;
	// Left와 Right가 같지 않다면 true 아니라면 false
	bResult = Left != Right;
	Result = Left != Right;

	// Left가 Right 크다면
	bResult = Left > Right;
	// Left가 Right 작다면
	bResult = Left < Right;

	// Left가 Right 크거나 같다면 커도 true 같아도 true
	bResult = Left >= Right;
	// Left가 Right 작거나 같다면
	bResult = Left <= Right;

	// 논리연산자
	// 참과 거짓을 기반으로 새로운 참과거짓을 만들어내는 연산자
	// 1항 혹은 단항이라고 불리는 연산자가 나옵니다.

	// 논리 부정 연산자 not연산자 입니다.
	bool bLeft = true;
	bool bRight = false;
	// true => false false => true
	bResult = !bLeft;

	// Left와 Right 모두 전부다 true 여야 true
	// 추후에 보충설명 하겠습니다.
	// 논리적 And
	bResult = true && true;
	bResult = true && false;

	// Left와 Right 둘중 하나만 true 여도 true
	// 추후에 보충설명 하겠습니다.
	// 논리적 Or
	bResult = false || false;
	bResult = false || true;

	// 비트단위 연산자.
	// C++ 

	// 2진수 표현입니다.
	// 0b표현식이 존재하지 않았습니다.
	// C++ 위원회에서 새롭게 0b를 사용할수 있습니다.


	// int BitTest = 0b00000000000000000000000000000011;

	//                  8421
	// 생략하면 앞쪽을 다 0이라고 생각합니다.
	Left = 0b0011;
	//                2+1
	Right = 0b0001;

	// 
	// 비트 연산자 And

	//   ||||
	// 0b0011
	// 0b0001
	// 0b0001
	Result = Left & Right;

	//   ||||
	// 0b1000
	// 0b0001
	// 0b0000
	Result = 0b1000 & 0b0001;

	// 비트단위 or 둘중 하나만 1이어도 1이다.
	//   ||||
	// 0b1000
	// 0b0001
	// 0b1001
	Result = 0b1000 | 0b0001;

	//     = 0b00000000000000000000000000000011;
	// int의 양수 최대값은
	// 정수에서 음수와 양수를 어떻게 표현하는가?
	// C++에서는 2의 보수법을 사용한다.

	// 2의 보수법이란
	// 어떤 메모리 영역이 존재할때 음수를 표현하고 싶다면
	// 1. 맨앞의 비트를 부호비트로 정한다.
	// 2. 그 부호비트가 1이면 음수
	//    0이면 양수라고 한다.
	// 3. 이때 부호가 음수면 
	//    비트가 0인 부분을 역으로 더한다.
	//       -1 -2
	Result = 0b11111111111111111111111111111101;

	// 32비트 정수범위 내에서 가장 큰 양수 양수 최대값
	Result = 0b01111111111111111111111111111111;

	// 32정수범위 내에서 가장 작은 음수 음수 최소값
	Result = 0b10000000000000000000000000000000;

	// 만약 4비트 정수가 있다고 한다면?
	// 0b1111 => -1

	// 양수 최대값
	// 0b0111 => 7
	// 음수 최소값
	// 0b1000 => -8

	// 0에 오류가 생겨서 이 표기법을 안씁니다.
	// Result = 0b10000000000000000000000000000000;
	// Result = 0b00000000000000000000000000000000;

	// 0b00000000000000000000000000001000;
	Result = 0b1000;

	// 비트 시프트 연산
	// 앞쪽 메모리 영역 << 뒤쪽 메모리영역
	//                    정수
	// Left 시프트 연산
	Result = 0b0001 << 1;
	// 맨 앞의 비트를 삭제하고 뒤쪽에 0을 추가하는 연산
	// Result = 0b00000000000000000000000000000010;

	// Right 시프트 연산
	Result = 0b0001 >> 1;
	// Result = 0b00000000000000000000000000000000;

	Result = 0b11111111111111111111111111111111 << 1;
	Result = 0b11111111111111111111111111111111 >> 1;
	Result = -1 >> 1;

	int Quest = 0b11111111111111111111110000000000;
	Quest = Quest | 1;

	bool Q0 = false;
	bool Q1 = false;
	bool Q2 = false;
	bool Q3 = false;
	bool Q4 = false;
	bool Q5 = false;
	bool Q6 = false;
	bool Q7 = false;
	bool Q8 = false;
	bool Q9 = false;

	Q0 = true;

	Result = 1 << 1;

	// Result = 숫자 * 2;

	// Result = 0b0001 | 0b0011;
	// Result = 0b0001 | 0b0011;

	// 배타적 논리합 xor
	// 양쪽이 다르면 1
	// 나머지는 0
	Result = 0b0001 ^ 0b0011;

	// 0b0001
	// 0b0011
	// 0b0010
	Result = 0b0001 ^ 0b0011;

	// 자신의 개쩌는 실력으로 내가 조금 손대면
	// 프로그램 2~3배씩 만든다.
	// 요즘 트랜드는 메모리를 좀 희생하는것
	// 비트단위는 별로 사용하지 않는다.

	// 컴파일러가 컴파일 시간에 처리하는 연산자로
	// 컴파일 타임 어써션을 이용하는 연산자이다.
	// int ByteSize = sizeof(int);

	// int ByteSize = sizeof(int);

	Result = ~0;

	// 변수 명으로도 사용할수 있고
	int ByteSize = 4;
	// 자료형으로도 쓸수 있다.
	ByteSize = sizeof(bool);

	Left = 3;
	Right = 5;

	// 삼항연산자는 
	//                    true일때 : false일때;
	Result = Left > Right ? 9999 : 1111;
	Result = true ? 9999 : 1111;
	Result = false ? 9999 : 1111;
	Result = 1111;

}
